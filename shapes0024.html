<!DOCTYPE html>
<html>
<head>
    <title>RNAFolding</title>
</head>
<body>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script>
 
// set up window size
var width = window.innerWidth,
    height = window.innerHeight,

// set variables for proportional display
    smallDim = Math.min(width, height),
    radius = smallDim / 20,
    textHeight = radius * 1.5,
    sizeFactor = smallDim / 900,
// needs background
    menuHeight = radius * 2,
    menuWidth = radius * 6,


// ? separate data to 2nd file
// data and coords for 1-1 loop
    nullData11 = ["X", "X", "X", "X"],

    nullCoords11 = [
 //       cx    cy
        [-80, -300],
        [80,  -300],
        [-80,  300],
        [80,   300]
    ],

    activeData11 = ["A", "A", "A", "A", "A", "A"], 

    activeCoords11 = [
 //       cx    cy
        [ -80, -140], // col 1         x  x
        [  80, -140], // col 2        c1  c2
        [-150,    0], // table 1    t1      t2
        [ 150,    0], // table 2      r1  r2
        [ -80,  140], // row 1         x  x
        [  80,  140]  // row 2
    ],

// data and coords for 2-2 loop
    nullData22 = ["X", "X", "X", "X"],

    nullCoords22 = [
 //       cx    cy
        [-80, -350],
        [ 80, -350],
        [-80,  350],
        [ 80,  350]
    ],

    activeData22 = ["A", "A", "A", "A", "A", "A", "A", "A"], 

    activeCoords22 = [
 //       cx    cy
        [ -80, -190], // col 1
        [  80, -190], // col 2        x  x
        [-190,  -80], // row 1       c1  c2
        [ 190,  -80], // row 2     r1      r2
        [-190,   80], // row 3     r3      r4
        [ 190,   80], // row 4       c3  c4
        [ -80,  190], // col 3        x  x
        [  80,  190]  // col 4
    ], 

// data and coords for hairpin
    nullDataHP = ["X", "X"],

    nullCoordsHP = [
 //       cx    cy
        [-80, -220],
        [ 80, -220]
    ],

    activeDataHP = ["A", "A", "A", "A", "A", "A"], 

    activeCoordsHP = [
 //       cx    cy
        [ -80, -60], // 1st nt          x  x
        [  80, -60], // 6th nt          1  6
        [-150,  80], // 2nd nt        2      5
        [ 150,  80], // 5th nt          3  4
        [ -80, 220], // 3rd nt
        [  80, 220]  // 4th nt
    ],

// data and coords for bulge -- needs bulge size menu of one to six nts -- 
// rough coords only -- needs exact coords --
    nullDataBG = ["X", "X", "X", "X", "X"],

    nullCoordsBG = [
 //       cx    cy
        [-80, -220],
        [ 80, -220],
        [135,   85],
        [-80,  350],
        [ 80,  350]
    ],

    activeDataBG = ["A", "A", "A", "A"], 

    activeCoordsBG = [
 //       cx    cy                  
        [ -80,  -60], //col 1        x   x
        [  80,  -60], //col 2       c1  c2             
        [ -135,  85], //row 1      r1    x 
        [    0, 190]  //row 2     x   r2
    ],                //             x

// data and coords for 1-2 loops 
// in progress -- not right -- needs exact coords --
    nullData12 = ["X", "X", "X", "X"],

    nullCoords12 = [
 //       cx    cy
        [-80, -350],
        [ 80, -350],
        [-80,  350],
        [ 80,  350]
    ],

    activeData12 = ["A", "A", "A", "A", "A", "A", "A"], 

    activeCoords12 = [
 //       cx    cy
        [ -80,  -60], // col 1       
        [  80,  -60], // col 2       x   x
        [ 135,   85], // row 2      c1   c2
        [   0, -190], // row 1     r1     r2
        [ 135,  -85], // row 3     c3    r3
        [-135,   85], // col 3    x   c4
        [   0,  190]  // col 4       x
    ],
    // pass different structMenuValue variations
    structMenuValue = ["Bulge", "Submit", "3nt", "1nt"],

    structMenuItems = [
        ["Bulge", "Hairpin", "1-1 Loop", "1-2 Loop", "2-2 Loop"],
        ["Submit", "Results"],
        ["3nt", "4nt", "5nt", "6nt", "7nt", "8nt", "9nt"],
        ["1nt", "2nts", "3nts", "4nts", "5nts", "6nts"]
        ],


    structMenuCoords = [
 //       x    y    
        [250, -150],
        [250,  -50],
        [250,  50],
        [250,  150]
    ],

// select the html body, add svg element to body, add group element 
// to svg. circles and text are contained in the group element
    svg = d3.select("body")
    .append("svg")
        .attr("width", width)
        .attr("height", height)
    .append("g")
// move origin of group element to center of svg
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

// pass in array of nts, class text subpart, and 2D array of coords
// display nts as dots per coordinates
function update(displayData, displayClass, displayCoords)  {

    var structureMenu = svg.selectAll(".stuctMenuRect") // select rects for outer menus
        .data(structMenuValue); // join structMenuValue to rectangle

    structureMenu.enter()
        .append("rect") // create rectangles
        .attr("class", "stuctMenuRect") // assign class to rectangles so svg.selectAll can find them
        .attr("x", function(d, i) {return structMenuCoords[i][0]}) //position rectangles
        .attr("y", function(d, i) {return structMenuCoords[i][1]})
        .attr("rx", radius / 4) // round corners
        .attr("ry", radius / 4)
        .attr("width", menuWidth) // set size
        .attr("height", menuHeight)
        .style("fill", "aqua"); // color inside rectangle

    // create text
    var structureText = svg.selectAll(".structText") // select text for outer menus
        .data(structMenuValue); // join initial selection to menu text

    structureText.enter() 
        .append("text") // create text elements
        .attr("class", "structText") //assign class to text elements so svg.selectAll can find them
        .attr("id", function(d, i) {return "structText" + i;}) // id each element so topRects can find them
        .text(function(d) {return d}) // insert inner text in element into
        .attr("x", function(d, i) {return structMenuCoords[i][0] + 3 * radius})
        .attr("y", function(d, i) {return structMenuCoords[i][1] + radius * 1.4})
        .attr("text-anchor", "middle")
        .style("font-size", textHeight + "px") // size
        .on("click", function(d, i) {
            for (var j = 0; j < structMenuItems[i].length; j++) {
                if (structMenuItems[i][j] == d) {
                    var newText = structMenuItems[i][(j + 1) % structMenuItems[i].length];
                    structMenuValue[i] = newText;
                    d3.select(this) // select text that user clicked
                        .data([newText]) // update data to new text
                        .text(newText);  // update text to new text

                    switch(newText) {
                        case structMenuItems[0][0]:
                            // draw null NTs above and SW of bulge and 1 in circle
                            update(nullDataBG, "null", nullCoordsBG);
                            // draw 4 NTs in circle of 5 NTs for bulge
                            activeDataBG = update(activeDataBG, "active", activeCoordsBG);
                            // now add in the number of nts 
                            break;
                        case structMenuItems[0][1]:
                            // draw null NTs above hairpin
                            update(nullDataHP, "null", nullCoordsHP);
                            //  draw circle of 6 NTs for hairpin
                            activeDataHP = update(activeDataHP, "active", activeCoordsHP);
                            break;
                        case structMenuItems[0][2]:
                            // draw null NTs above and below 1-1 loop
                            update(nullData11, "null", nullCoords11);
                            // draw circle of 6 NTs for 1-1 loop
                            activeData11 = update(activeData11, "active", activeCoords11);
                            break;
                        case structMenuItems[0][3]:
                            // draw null NTs above and SW of 1-2 loop
                            update(nullData12, "null", nullCoords12);
                            // draw 7 NTs in circle for 1-2 loop
                            activeData12 = update(activeData12, "active", activeCoords12);
                            break;
                        case structMenuItems[0][4]:
                            // draw null NTs above and below 2-2 loop
                            update(nullData22, "null", nullCoords22);
                            // draw circle of 8 NTs for 2-2 loop
                            activeData22 = update(activeData22, "active", activeCoords22);
                            break;
                        case structMenuItems[1][0]:
                            // import JSON file
                            var loop_2_2={};
                            $.getJSON('loop_2_2.json', function(data) { 
                            loop_2_2 = data;
                            }); 

                            var loop_1_2={};
                            $.getJSON('loop_1_2.json', function(data) { 
                            loop_1_2 = data;
                            }); 

                            var bulge_1nt={};
                            $.getJSON('bulge_1nt.json', function(data) { 
                            bulge_1nt = data;
                            }); 

                            var bulge_2nt={};
                            $.getJSON('bulge_2nt.json', function(data) { 
                            bulge_2nt = data;
                            }); 

                            var bulge_3nt={};
                            $.getJSON('bulge_3nt.json', function(data) { 
                            bulge_3nt = data;
                            }); 

                            var bulge_4nt={};
                            $.getJSON('bulge_4nt.json', function(data) { 
                            bulge_4nt = data;
                            }); 

                            var bulge_5nt={};
                            $.getJSON('bulge_5nt.json', function(data) { 
                            bulge_5nt = data;
                            }); 

                            var bulge_6nt={};
                            $.getJSON('bulge_6nt.json', function(data) { 
                            bulge_6nt = data;
                            }); 

                            var hairpin={};
                            $.getJSON('hairpin.json', function(data) { 
                            hairpin = data;
                            }); 

                            var loop_1_1_GG={};
                            $.getJSON('loop_1_1_GG.json', function(data) { 
                            loop_1_1_GG = data;
                            }); 

                            var loop_1_1_UU={};
                            $.getJSON('loop_1_1_UU.json', function(data) { 
                            loop_1_1_UU = data;
                            }); 

                            var loop_1_1_noboost={};
                            $.getJSON('loop_1_1_noboost.json', function(data) { 
                            loop_1_1_noboost = data;
                            }); 
                                
                            // when data is submitted:
                            // get current type of RNA

                            var rnaType = structMenuValue[0],
                                hairpinType = structMenuValue[1],
                                bulgeType = structMenuValue[2],
                                colNucs = "",
                                rowNucs = "",
                                refTable;


                            if (rnaType == "Bulge"){
                                // get nucleotides
                                nucs = activeDataBG;
                                colNucs = nucs[0] + nucs[1];
                                rowNucs = nucs[2] + nucs[3];
                                if (bulgeType == "1nt"){
                                    refTable = bulge_1nt;
                                } else if (bulgeType == "2nts"){
                                    refTable = bulge_2nt;
                                } else if (bulgeType == "3nts"){
                                    refTable = bulge_3nt;
                                } else if (bulgeType == "4nts"){
                                    refTable = bulge_4nt;
                                } else if (bulgeType == "5nts"){
                                    refTable = bulge_5nt;
                                } else if (bulgeType == "6nts"){
                                    refTable = bulge_6nt;
                                }
                            } else if (rnaType == "Hairpin"){
                                // get nucleotides
                                nucs = activeDataHP;
                                // are there Ns in it? --> deal with that later
                                colNucs = hairpinType;
                                rowNucs = nucs[0] + nucs[2] + nucs[4] + nucs[5] + nucs[3] + nucs[1];
                                refTable = hairpin; 
                            } else if (rnaType == "1-1 Loop"){
                                // get nucleotides
                                nucs = activeData11;
                                colNucs = nucs[0] + nucs[1];
                                rowNucs = nucs[4] + nucs[5];
                                //find subset of 11 loop
                                if (nucs[2] == "G" && nucs[3] == "G"){
                                    refTable = loop_1_1_GG; 
                                } else if (nucs[2] == "A" && nucs[3] == "A"){
                                    refTable = loop_1_1_noboost; 
                                } else if (nucs[2] == "U" && nucs[3] == "U"){
                                    refTable = loop_1_1_UU; 
                                };
                            } else if (rnaType == "1-2 Loop"){
                                // get nucleotides
                                nucs = activeData12;
                                colNucs = nucs[0] + nucs[1] + nucs[6] + nucs[7]; 
                                rowNucs = nucs[2] + nucs[3] + nucs[4] + nucs[5];
                                refTable = loop_1_2;
                            } else if (rnaType == "2-2 Loop"){ 
                                // get nucleotides
                                nucs = activeData22;
                                colNucs = nucs[0] + nucs[1] + ":" + nucs[6] + nucs[7];
                                rowNucs = nucs[3] + nucs[4] + "-" + nucs[5] + nucs[6];
                                refTable = loop_2_2;
                            };

                                function getResult(refFile, colNucArray, rowNucArray){
                                    result = refFile[colNucArray][rowNucArray];


                                    var headingValues = ["column", "row", "energy"];

                                    var headingText = svg.selectAll(".headingText")
                                        .data(headingValues);

                                    headingText.enter()
                                        .append("text");

                                    headingText.attr("class", "headingText")
                                        .attr("x", function(d, i) {return 0 + i * 30;})
                                        .attr("y", -0)
                                        .text(function(d) {return d;})
                                        .attr("text-anchor", "middle")
                                        .style("font-size", textHeight / 2 + "px");
/*
                                    var tempArray = [
                                        ["abcd", "abcd2", 2.0],
                                        ["rxkmd", "xyz", 0.7]
                                     ];

                                     var newTempArray = [];
  
                                    for (var i = 0; i < tempArray.length; i++) {
                                        newTempArray[i] = tempArray[i].slice(0, 1)
                                    };

*/


                                    //remember to set results to monospace

                                    // display table with :
                                    // column   row     energy
                                    // colNucArray  rowNucArray     result
                                }

                                getResult(refTable, colNucs, rowNucs);
                                // display all matching colNucArray(take into consideration R (AG), Y (CU), N (AUGC)) and value returned

                             break;

                        default:
                            // nothing
                    };

                };
            };
    });

    structureText.exit().remove();


    var topRects = svg.selectAll(".topRects") // select topRects for outer menus
        .data(structMenuValue); // join structMenuValue to rectangle

    topRects.enter()
        .append("rect");

    topRects.attr("class", "topRects") // assign class to rectangles so svg.selectAll can find them
        .attr("x", function(d, i) {return structMenuCoords[i][0]}) //position rectangles
        .attr("y", function(d, i) {return structMenuCoords[i][1]})
        .attr("rx", radius / 4) // round corners
        .attr("ry", radius / 4)
        .attr("width", menuWidth) // set size
        .attr("height", menuHeight)
        .style("fill", "rgba(0, 0, 0, 0)") // fill rect with transparent black
        // add gray outline on mouseover
        .on("mouseover", function(){d3.select(this)
            .style("stroke", "gray")
            .style("stroke-width", 4);})
        // remove gray outline when not mouseover
        .on("mouseout", function(){d3.select(this)
            .style("stroke", "gray")
            .style("stroke-width", 0);})
        .on("click", function(d, i) {
            for (var j = 0; j < structMenuItems[i].length; j++) {
                if (structMenuItems[i][j] == d) {
                    var newText = structMenuItems[i][(j + 1) % structMenuItems[i].length];
                    structMenuValue[i] = newText;
                    d3.select("#structText" + i) // select text that user clicked
                        .data([newText]) // update data to new text
                        .text(newText);  // update text to new text
                };
            };
        })

        ;

    // change to use structure with variable name nucleotide
    // lookup table for nt names and colors
        var nucleoArray = [
        //         nt              name        color
            {key: "A", values: ["Adenine",    "yellow"]}, 
            {key: "U", values: ["Uracil",     "blue"]}, 
            {key: "G", values: ["Guanine",    "red"]}, 
            {key: "C", values: ["Cytosine",   "green"]}, 
            {key: "R", values: ["puRine",     "orange"]}, 
            {key: "Y", values: ["pYrimidine", "turquoise"]}, 
            {key: "N", values: ["unkNown",    "silver"]},
            {key: "X", values: ["X null",     "pink"]}
        ];
      
        // draw a dot for each value in displayData per coords in displayData
        // select all circles of current display class
        var circles = svg.selectAll("." + displayClass + "Circle")
            .data(displayData); // join displayData to selected circles

        circles.enter() // create an enter subsection
            .append("circle"); // add circles as needed

        circles.attr("class", displayClass + "Circle") // set class so selectAll can find circles
            // add ids by index so single dots can be selected
            .attr("id", function(d, i) {return displayClass + "Circle" + i;})// id for individual color cycling
            .text(function(d) {return d}) // insert text from data into inner html
            .attr("r", radius) //set dot size
            .attr("cx", function(d, i) {return displayCoords[i][0] * sizeFactor}) // position circles
            .attr("cy", function(d, i) {return displayCoords[i][1] * sizeFactor}) 
            .style("fill", function(d, i) { // color inside circles
                var j = 0;
                for (j = 0; j < nucleoArray.length; j++) { // look thru nucleoArray
                    if(nucleoArray[j].key == d) { // find color for current value
                        return nucleoArray[j].values[1];
                    };
                };
                
            });

        circles.exit().remove(); // delete any leftover elements
        
        if (displayClass == "active") { // only allow active nts to respond to mouse
            // add gray outline on mouseover
            circles.on("mouseover", function(){d3.select(this)
                .style("stroke", "gray")
                .style("stroke-width", 4);})
            // remove gray outline when not mouseover
            .on("mouseout", function(){d3.select(this)
                .style("stroke", "gray")
                .style("stroke-width", 0);});};

    // text on circles takes mouseover focus away from circle
    // needs fix  -- text mouseovers demonstrate this

    var text = svg.selectAll("." + displayClass + "Text") // select current potential text of displayClass
            .data(displayData);  // join displayData to selected text

        text.enter() 
            .append("text"); // add empty text elements

        text.attr("class", displayClass + "Text")// set class so selectAll can find text elements
            .attr("id", function(d, i) {return  displayClass + "Text" + i;}) // id so topCircles can find corresponding text
            .text(function(d) {return d}) // add text from
            .attr("x", function(d, i) {return displayCoords[i][0] * sizeFactor}) // position
            .attr("y", function(d, i) {return displayCoords[i][1] * sizeFactor + textHeight / 2.8})
            .attr("text-anchor", "middle") // position text by its middle
            .style("font-size", textHeight + "px"); // size 

        text.exit().remove(); // delete any leftover elements

    // shows how text takes focus of mouseover from dots
        if (displayClass == "active") {  // only allow active nts to respond to mouse
            // add gray outline on mouseover
            text.on("mouseover", function(){d3.select(this)
                .style("stroke", "gray")
                .style("stroke-width", 4);})
                // remove gray outline when not mouseover
                .on("mouseout", function(){d3.select(this)
                    .style("stroke", "gray")
                    .style("stroke-width", 0);})
                // on click display next nucleotide
                .on("click", function(d, i) {
                    var j = 0;
                    // cycle thru nucleoArray by j, match key to d and get new key and fill value
                    for (j = 0; j < nucleoArray.length; j++) {
                        if (nucleoArray[j].key == d) {
                            var newKey = nucleoArray[(j + 1) % (nucleoArray.length - 1)].key; //get next nucleotide
                            var newFill = nucleoArray[(j + 1) % (nucleoArray.length - 1)].values[1]; // get next color
                            d3.select(this) //select text for nt that user clicked
                                .data(newKey) // update data 
                                .text(newKey);  // update text to new key
                            displayData[i] = newKey;  // update displayData to new key
                            d3.select("#" + displayClass + "Circle" + i) //select circle behind clickedText
                                .style("fill", newFill);  // and update to new fill
                        };
                    };
                });

            // make clear dots to click on
            topCircles = svg.selectAll(".topCirc")
                .data(displayData);

            topCircles.enter()
                .append("circle");

            topCircles.attr("class", "topCirc")
                .attr("id", function(d, i) {return "topCirc" + i})
                .attr("cx", function(d, i) {return d3.select("#" + displayClass + "Circle" + i).attr("cx")})
                .attr("cy", function(d, i) {return d3.select("#" + displayClass + "Circle" + i).attr("cy")})
                .attr("r", radius)
                .style("fill", "rgba(0, 0, 0, 0)") // fill dot with transparent black
                .on("mouseover", function(){d3.select(this)
                .style("stroke", "gray")
                .style("stroke-width", 4);})
                // remove gray outline when not mouseover
                .on("mouseout", function(){d3.select(this)
                    .style("stroke", "gray")
                    .style("stroke-width", 0);})
                // on click display next nucleotide
                .on("click", function(d, i) {  //  why will text and color circle increment only once
                    // the values in display data do increment
                    var j = 0;
                    // cycle thru nucleoArray by j, match key to d and get new key and fill value
                    for (j = 0; j < nucleoArray.length; j++) {
                        if (nucleoArray[j].key == d) {
                            var newKey = nucleoArray[(j + 1) % (nucleoArray.length - 1)].key; //get next nucleotide
                            var newFill = nucleoArray[(j + 1) % (nucleoArray.length - 1)].values[1]; // get next color
                            d3.select("#" + displayClass + "Text" + i) //select text element under clicked disk
                                .data(newKey) // update text element's data 
                                .text(newKey); // update text element's inner text
                            d3.select(this) //select clicked topCircle
                                .data(newKey);
                            displayData[i] = newKey;  // update displayData to new key
                            d3.select("#" + displayClass + "Circle" + i) //select circle behind clickedText
                                .style("fill", newFill);  // and update to new fill
                        };
                    };
                });
            
            topCircles.exit().remove(); // get rid of any top circles not associated with data members


        };
        return displayData;
}
//rewrite so update is called only once
// draw null NTs above and SW of bulge and 1 in circle
update(nullDataBG, "null", nullCoordsBG);
// draw 4 NTs in circle of 5 NTs for bulge
activeDataBG = update(activeDataBG, "active", activeCoordsBG);


</script>
</body>
</html>
